/**
  ******************************************************************************
  * \file    timer.c
  * \author  Абдуллаев Тимур
  * \version 1.0.0
  * \date    13.03.2022
  * \brief   Программа на языке C для учебного стенда на базе
  *          STM32F072RBT6 в среде разработки Keil uVision 5.
  *          Подключение библиотек поддержки МК STM32F072RBT6 осуществляется
  *          средствами IDE Keil через менеджер пакетов менеджер пакетов менеджер пакетов Run-Time Environment (RTE).
  *          Разработать программу, обеспечивающую управление бегущим огнем
  *          на светодиодах D1-D8: один огонь бежит справо налево
  *          с постоянной невысокой скоростью  при этом яркость плавно нарастает и спадает (пульсирует). 
  *          При нажатии на SB1 меняется цвет светодиода, а при 
  *          нажатии на SB2 меняется направление пробега.
  *          Программа работает в режиме 1 учебного стенда (S1 = 0, S2 = 1).	
  ******************************************************************************
  */

/* Подключение заголовочного файла с макроопределениями всех регистров специальных
   функций МК STM32F072RBT6. */
#include <stm32f0xx.h>

void software_delay(int ticks)
{
	while(ticks>0)
	{
		ticks = ticks-1;
	}
}

/* Функция инициализации светодиодов D1-D8 и линий управления цветом */
void leds_init(void)
{
    /* Включение тактирования порта A */
    RCC->AHBENR |= RCC_AHBENR_GPIOAEN;

    /* Включение тактирования порта C */
    RCC->AHBENR |= RCC_AHBENR_GPIOCEN;

    /* Настройка на вывод линий PA6, PA7, PA8 (RED, GREEN, BLUE) */
    GPIOA->MODER |= (GPIO_MODER_MODER6_0 | GPIO_MODER_MODER7_0 | GPIO_MODER_MODER8_0);

    /* Настройка на вывод линий PC0 - PC7 (D1 - D8) */
    GPIOC->MODER |= GPIO_MODER_MODER0_0 | GPIO_MODER_MODER1_0 | GPIO_MODER_MODER2_0 |
                    GPIO_MODER_MODER3_0 | GPIO_MODER_MODER4_0 | GPIO_MODER_MODER5_0 |
                    GPIO_MODER_MODER6_0 | GPIO_MODER_MODER7_0;
}

/* Макроопределения с цветами */
#define RED     0
#define GREEN   1
#define BLUE    2
#define SB1 4
#define SB2 5
int i = 0;

/* Переменная для сохранения состояния светодиодов */
uint16_t led = 0x01; /* Начальное состояние - включен самый правый светодиод */
/* Переменная для сохранения цвета светодиодов */
uint16_t color = RED; /* Начальное состояние - красный цвет */
/* Переменная для подсчета количества переполнений */
uint16_t up_cnt = 0;
/* Переменная для сохранения яркости - код в канале выходного сравнения ( яркость в начальный момент) */
uint16_t brightness = 999;
/* переменная для изменения направления */
uint16_t direction = 1;

uint16_t y = 0;
//Функция инициализации кнопок SB1 и SB2 и ключей SW1 и SW2
void sbw_init(void)
{
    /* Включение тактирования порта B */
    RCC->AHBENR |= RCC_AHBENR_GPIOBEN;

    /* Включение подтягивающих резисторов PB4 (SB1) и PB5 (SB2) */
    GPIOB->PUPDR |= GPIO_PUPDR_PUPDR4_0 | GPIO_PUPDR_PUPDR5_0;
	
		// EXTI - расширенный контроллер прерываний
		// IMR - регистр маски прерываний
		// RTSR - регистр выбора повышающего триггера (обнуружение фронта)
		// FTSR - регистр выбора падающего триггера   (обнуружение фронта)
		// SYSCFG - контроллер конфигурации системы
		// external interrupt configuration register - регистр конфигурации внешнего прерывания
	
    /* Разрешение прерывания по линиям EXTI4, EXTI5,  в регистре
       Interrupt mask register (IMR) */
    EXTI->IMR |= EXTI_IMR_MR4 | EXTI_IMR_MR5;

    /* Разрешение прерывания по фронту по линиям EXTI4, EXTI5,  в регистре
       Rising trigger selection register(RTSR) */
    EXTI->RTSR |= EXTI_RTSR_RT4 | EXTI_RTSR_RT5;

    /* Разрешение прерывания по спаду по линиям EXTI4, EXTI5,  в регистре
       Falling trigger selection register(FTSR) */
    EXTI->FTSR |= EXTI_FTSR_FT4 | EXTI_FTSR_FT5;

    /* Включение тактирования модуля System configuration controller (SYSCFG) */
    RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;

    /* Подключение линии EXTI4 к выводу PB4, EXTI5 к выводу PB5, EXTI11 к выводу PA11 и EXTI12 к выводу PA12 в регистре
       SYSCFG external interrupt configuration register (EXTICR2, EXTICR3, EXTICR4) */
    SYSCFG->EXTICR[1] |= SYSCFG_EXTICR2_EXTI4_PB | SYSCFG_EXTICR2_EXTI5_PB;
		

		//[1] - PB, [0] - PA, CR2-EXTI4:7; CR3-EXTI8:11; CR4-EXTI12:15;
		
    /* Сброс флага вызвавшего прерывание в регистре
       Pending register(PR) */
    EXTI->PR |= EXTI_PR_PIF4 | EXTI_PR_PIF5;

    /* Установка приоритета прерываний.
       В Cortex-M0 четыре уровня приоритета - 0-3.
       0 - наибольший приоритет, 3 - наименьший. */
    NVIC_SetPriority(EXTI4_15_IRQn, 0);

    /* Разрешение прервания по линиям EXTI4-EXTI15 */
    NVIC_EnableIRQ(EXTI4_15_IRQn);

}

/* Функция получения состояния кнопок, sb_num - номер считываемой кнопки */
int sb_get_state(uint8_t sb_num)
{
    /* Чтение состояния кнопки */
    uint16_t pin = (GPIOB->IDR >> sb_num) & 1;

    /* Если состояние кнопки было 0, то кнопка нажата */
    if (pin == 0)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

/* Подпрограмма обработчик прерываний от запросов на внешние прерывания
   портов ввода/вывода по линиям 4-15 */
void EXTI4_15_IRQHandler(void)
{
    /* Сброс флага вызвавшего прерывание в регистре
       Pending register(PR) */
    EXTI->PR |= EXTI_PR_PIF4 | EXTI_PR_PIF5;

    /* Чтение состояния кнопок */
	//если нажать SB1, то поменяется цвет
    if(sb_get_state(SB1) == 1 && color == RED){
		up_cnt = 0; // обнуляем счетчик мс
		color = BLUE;
		software_delay(500000);
		}	
		else if(sb_get_state(SB1) == 1 && color == BLUE){
		up_cnt = 0; // обнуляем счетчик мс
		color = GREEN;
		software_delay(500000);
		}
		else if(sb_get_state(SB1) == 1 && color == GREEN){
		up_cnt = 0; // обнуляем счетчик мс
		color = RED;
		software_delay(500000);
		}
		
		
		//если нажать SB2, то поменяется направление
		if(sb_get_state(SB2) == 1 && direction == 1){
		up_cnt = 0; // обнуляем счетчик мс
		direction = 2; // меняем направление
		software_delay(200000);
		}
		else if(sb_get_state(SB2) == 1 && direction == 2){
		up_cnt = 0; // обнуляем счетчик мс
		direction = 1; // меняем направление
		software_delay(200000);
		}
}


/* Функция включения светодиодов и выбора цвета */
void led_set(uint8_t led, uint8_t color)
{
    /* Записываем в регистр данных порта C новое состояние светодиодов.
       Номер бита соответствует номеру светодиода: бит 0 - D1, бит 1 - D2 и
       так далее */
    GPIOC->ODR = led;

    /* Сброс трех битов управления цветом с помощью маски */
    GPIOA->ODR &= ~(7 << 6);

    /* Включение светодиодов нужного цвета */
    if (color == RED) {
        GPIOA->ODR |= (1 << 6);
    }
    else if (color == GREEN) {
        GPIOA->ODR |= (1 << 7);
    }
    else if (color == BLUE) {
        GPIOA->ODR |= (1 << 8);
    }
}



/* Функция инициализации таймера TIM1 */
void timer_init()
{
    /* Включение тактирования TIM1 */
    RCC->APB2ENR |= RCC_APB2ENR_TIM1EN;

    /* Расчет предделителя частоты и кода переполнения таймера
       (максимальный код таймера).
       Пусть таймер счетчик переключается каждую 1 мкс или 1 МГц,
       тогда при частоте тактирования МК fmcu = 8 МГц, 
	     предделитель требуется
       на 8 - 8 МГц / 1 МГц = 8.
       Пусть переполнение происходит каждую 1 мс или 1 кГц,
       тогда код переполнения должен быть 1 МГц / 1 кГц = 1000 */
	
	/* Предделитель частоты  (если она меньше то быстрее скорость и наоборот)
	задаем 8 мкс
	*/
    TIM1->PSC = 8;

	/* Максимальный код таймера (счет идет от 0 до 999) т.е. 1000 мкс = 1 мс */
    TIM1->ARR = 999;

    /* Начальный код в регистре выходного сравнения 
		250 мкс
		
		*/
    TIM1->CCR1 = 999;

    /* Включение прерывания по переполнению */
    TIM1->DIER |= TIM_DIER_UIE;

    /* Включение прерывания по сравнению - канал 1 */
    TIM1->DIER |= TIM_DIER_CC1IE;

    /* Включить таймер */
    TIM1->CR1 |= TIM_CR1_CEN;

    /* Установка приоритета прерывания по переполнению таймера.
       В Cortex-M0 четыре уровня приоритета - 0-3.
       0 - наибольший приоритет, 3 - наименьший. */
			 
    NVIC_SetPriority(TIM1_BRK_UP_TRG_COM_IRQn, 0);

    /* Установка приоритета прерывания по сравнению. */
    NVIC_SetPriority(TIM1_CC_IRQn, 0);

    /* Разрешение прервания по переполнению */
    NVIC_EnableIRQ(TIM1_BRK_UP_TRG_COM_IRQn);

    /* Разрешение прервания прерывания по сравнению. */
    NVIC_EnableIRQ(TIM1_CC_IRQn);
}


/* Подпрограмма обработчик прерываний по переполнению таймера */
void TIM1_BRK_UP_TRG_COM_IRQHandler(void)
{
    /* Сброс флага вызвавшего прерывание */
    TIM1->SR &= ~TIM_SR_UIF;

    /* Подсчет количества переполнений таймера.
       Между каждым переполнением проходит по 1 мс */
    up_cnt++;
	y++;
	
	if (y> 50) {
		if (brightness == 999) {
			brightness = 499;
		} else {
			brightness = 999;
		}
		y=0;
	}
		
	
	

    /* Если прошло больше 250 мс */
    if (direction == 1){
        /* Если прошло больше 250 мс */
		if (up_cnt > 250) {
			/* Подсчет заново */
			up_cnt = 0;
			/* Сдвиг маски светодиода на одну позицию влево */
			led = led << 1;
		}
			
		if (led == 0x100) {
			led = 0x001;
		}
	} else if (direction == 2){
		if (up_cnt > 250){
			/* Подсчет заново */
			up_cnt = 0;
			/* Сдвиг маски светодиода на одну позицию вправо */
			led = led >> 1;
		}
            /* Если сдвиг произошел дальше 1 светодиода */
			if (led == 0x000){
				led = 0x80;
			}
		}	
    /* Включение светодиода с нужным цветом */
    led_set(led, color);

    /* Запись в регистр выходного сравнения нового кода */
    TIM1->CCR1 = brightness;
}

/* Подпрограмма обработчик прерываний по выходному сравнению таймера */
void TIM1_CC_IRQHandler(void) {
    /* Сброс флага вызвавшего прерывание */
    TIM1->SR &= ~TIM_SR_CC1IF;

    /* Выключение всех светодиодов */
    led_set(0, color);
}

/* Функция main - точка входа в программу */
int main(void) {
    /* Инициализация светодиодов D1-D8 и управления цветом */
    leds_init();
    /* Инициализация таймера TIM1 */
    timer_init();
	/* Инициализация кнопок */
	sbw_init();
    /* Бесконечный цикл */
    while (1)
    {
        /* Основные действия происходят в подпрограммах обработчиках
           прерываний.
        */
    }
}